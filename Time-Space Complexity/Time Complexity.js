// It is used to measure efficiency of algorithm in terms of speed, as the input size grows

// Time complexity != Time taken
// Time taken depends on which machine we run the code on, what language are we using etc.

// Speed efficiency => when input size grows

// Linear Search - loop runs n times checking each element in the array. - O(n)

// Binary Search - it runs n, n/2, n/4, n/8 and so on.
// n/2 * 1/2 * 1/2 * 1/2 .... x times
// which is n/2^x = 1
// n = 2^x
// log 2^n = x => log(n)

// Linear Search
// n = 10, x = 10
// n = 100, x = 100
// n = 1000, x = 1000

// Binary Search
// n = 10, x = 3
// n = 100, x = 7
// n = 1000, x = 10

// Big O notation (always consider worst case and represents the worst case)
// Linear Search => O(n)
// Binary Search => O(log n)
// Efficiency O(log n) >> O(n)


// Time Complexities
// 1. O(n)
// 2. O(log n)
// 3. O(n log n) -> example -> merge sort
// 4. O(n^2)
// 5. O(n^3)
// 6. O(2^n)
// 7. O(n!) -> worst of all
// 8. O(1) -> constant time complexity (best of all)

// O(1) >> O(log n) >> O(n) >> O(n log n) >> O(n^2) >> O(2^n) >> O(n!)


































































































